/*
小 w 在赛场上遇到了这样一个题：一个长度为 n 且符合规范的括号序列，其有些位置已经确定了，有些位置尚未确定，求这样的括号序列一共有多少个。

身经百战的小 w 当然一眼就秒了这题，不仅如此，他还觉得一场正式比赛出这么简单的模板题也太小儿科了，于是他把这题进行了加强之后顺手扔给了小 c。

具体而言，小 w 定义“超级括号序列”是由字符 (、)、* 组成的字符串，并且对于某个给定的常数 k，给出了“符合规范的超级括号序列”的定义如下：

()、(S) 均是符合规范的超级括号序列，其中 S 表示任意一个仅由不超过 k 个字符 * 组成的非空字符串（以下两条规则中的 S 均为此含义）；

如果字符串 A 和 B 均为符合规范的超级括号序列，那么字符串 AB、ASB 均为符合规范的超级括号序列，其中 AB 表示把字符串 A 和字符串 B 拼接在一起形成的字符串；

如果字符串 A 为符合规范的超级括号序列，那么字符串 (A)、(SA)、(AS) 均为符合规范的超级括号序列。

所有符合规范的超级括号序列均可通过上述 3 条规则得到。

例如，若 k=3，则字符串 ((**()*(*))*)(***) 是符合规范的超级括号序列，但字符串 *()、(*()*)、((**))*)、(****(*)) 均不是。特别地，空字符串也不被视为符合规范的超级括号序列。

现在给出一个长度为 n 的超级括号序列，其中有一些位置的字符已经确定，另外一些位置的字符尚未确定（用 ? 表示）。小 w 希望能计算出：有多少种将所有尚未确定的字符一一确定的方法，使得得到的字符串是一个符合规范的超级括号序列？

可怜的小 c 并不会做这道题，于是只好请求你来帮忙。
*/

int n,k,f[N][N],g[N][N],h[N][N];
char s[N];

bool match(int x,char y){
	return s[x]=='?'||s[x]==y;
}

void add(int &x,int y){
	x+=y;
	if(x>=mod) x-=mod;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
	scanf("%d%d%s",&n,&k,s+1);
	for(int d=1;d<n;++d){
		for(int l=1;l+d<=n;++l){
			int r=l+d;
			if(match(l,'(')&&match(r,')')){
				//()
				if(r==l+1) add(g[l][r],1);
				else if(r-l-1<=k){
					//(S)
					int ans=1;
					for(int i=l+1;i<r;++i){
						if(!match(i,'*')){
							ans=0;
							break;
						}
					}
					add(g[l][r],ans);
				}
				//(A)
				add(g[l][r],f[l+1][r-1]);
				//(SA)
				/*for(int i=l+1;i<r-1&&i-l<=k;++i){
					if(!match(i,'*')) break;
					add(g[l][r],f[i+1][r-1]);
				}*/
				add(g[l][r],h[l+1][r-1]);
				//(AS)
				for(int i=r-1;i>l+1&&r-i<=k;--i){
					if(!match(i,'*')) break;
					add(g[l][r],f[l+1][i-1]);
				}
			}
			f[l][r]=g[l][r];
			if(match(l,'(')&&match(r,')')){
				for(int m=l+1;m<r;++m){
					int tmp=0;
					//AB
					add(tmp,f[m+1][r]);
					//ASB
					add(tmp,h[m+1][r]);
					/*
					for(int j=m+1;j<r&&j-m<=k;++j){
						if(!match(j,'*')) break;
						add(tmp,f[j+1][r]);
					}*/
					add(f[l][r],(ll)tmp*g[l][m]%mod);//()+()()与()()+()重复，所以枚举第一个合法的1，3种情况(因为第二种情况总是由一堆的第1，3种情况组成)第1，3种情况不存在两个)
				}
			}
			for(int j=l;j<r&&j-l+1<=k;++j){
				if(!match(j,'*')) break;
				add(h[l][r],f[j+1][r]);
			}
		}
	}
	printf("%d",f[1][n]);
    return 0;
}